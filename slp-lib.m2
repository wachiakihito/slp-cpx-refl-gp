-- slp-lib.m2
-- Library to check the strong Lefschetz property
--
-- Copyright (c) 2023 akihito wachi
-- Released under the MIT license
-- https://opensource.org/licenses/mit-license.php

-- Functions defined in this file:
-- hilb, hilb2, isSLE, isSLEx, isSLEm, modpOf

-- The following two functions return Hilbert function (a list of
-- dimension of homogeneous components).
-- 
-- hilb(I)  for graded Artinian algebra R/I over QQ.
-- hilb2(I) for those over algebraic extension of QQ.
--
-- If the coefficient field is an algebraic extension of QQ, then you
-- must overwrite as 'hilb = hilb2' beforehand in order that the other
-- functions fit into the algebraic extension.

-- The following three functions check if 'elt' is a strong
-- Lefschetz element of a graded Artinian algebra R/I.
--
-- isSLE(I, elt)  for symmetric Hilbert function
-- isSLEx(I, elt) for not necessarily symmetric Hilbert function
-- isSLEm(I, elt) for symmetric Hilbert function, uses initial ideal
--
-- isSLEm is fastest in many cases when 'elt' is a strong Lefschetz
-- element.

-- The following function sets up the finite field setting.
--
-- modpOf(I, p) returns the ideal Imodp of Rmodp,
-- modpOf2(I, p) returns the ideal Imodp2 of Rmodp,
--
-- where Rmodp is the polynomial ring over ZZ/p with the same
-- variables as R, and Imodp is generated by Gmodp.  Gmodp is defined
-- as G mod p, where G is a Groebner basis of I with integral
-- coefficients. Initial coefficients of G should not be divisible by p.
--
-- The ideal Imodp2 is equal to Imodp, but generators are images of
-- generators of I (not of G) by mod p. modpOf2 returns Imodp2 only if
-- it is equal to Imodp, otherwise generates an error.
--
-- In this setting, R/I has the SLP if Rmodp/Imodp has the SLP
-- (Converse is not true).


-- Clear fractions of a polynomial
clearFraction = f -> (
  R := ring f;
  R2Q := map(QQ, R);
  cs := flatten entries last coefficients f;
  a := lcm apply(cs, c -> denominator R2Q c);
  b := gcd apply(cs, c -> numerator R2Q c);
  f * (a/b)
)

-- Hilbert function of graded Artinian ring R/I
hilb = I -> (
  flatten entries last coefficients numerator reduceHilbert hilbertSeries I
)

-- Hilbert function of graded Artinian ring R/I,
-- when the coefficient ring is an algebraic extension of a prime field.
--
-- [NOTICE]
-- In checking SLP by using the functions below such as 'isSLE', you
-- must overwrite as 'hilb = hilb2' beforehand, when the coefficient
-- ring is an algebraic extension of a prime field.
hilb2 = I -> (
  h := numerator reduceHilbert hilbertSeries I;
  h2 := sub(h, (gens ring h)#1 => 0);
  flatten entries last coefficients h2
)

-- Check if 'elt' is a strong Lefschetz element of R/I
-- R/I should be Artinian and symmetric.
isSLE = (I, elt) -> (
  R := ring I;
  h := hilb I;
  socdeg := #h - 1;
  for i from 0 to floor((socdeg-1)/2) do (
    J := I + ideal{elt^(socdeg-i*2)};
    if (#(hilb J) > socdeg-i) then { return false }
  );
  true
)

-- Check if 'elt' is a strong Lefschetz element of R/I
-- R/I should be Artinian, and may not be symmetric.
-- Of course slower than isSLE.
isSLEx = (I, sle) -> (
  pseq := hilb I;
  socdeg := #pseq - 1;
  dimseq := apply(socdeg+1, d->(
    sum hilb ideal(gens I | (sle^(d+1)))));
  kerdimseq := take(append(dimseq, 0) - prepend(0, dimseq), socdeg+1);
  kerdimseq == (reverse sort pseq)
)

-- Check if 'elt' is a strong Lefschetz element of R/I.
-- R/I should be Artinian and symmetric.
-- Change the coordinate so that the last variable corresponds to 'elt' (say J),
-- and check if the last variable is a strong Lefschetz element in R/in(J).
-- See [Wiebe, Proposition 2.9], [Numata-Wachi2007, Lemma 2].
isSLEm = (I, elt) -> (
  R := ring I;
  xn := last gens R;
  c := elt_xn;
  if (c == 0) then (
    error "coefficient of last variable should not be zero";
    return;
  );
  yn := c^(-1) * ((1+c)*xn - elt);
  J := ideal apply(flatten entries gens I, f -> sub(f, xn => yn));
  inJ := ideal apply(flatten entries gens gb J, f -> first terms f);
  isSLE(inJ, xn)
)

-- For a Groebner basis G of an ideal I of R = QQ[x1,..,xn] and a
-- prime p, check initial coefficients of G are not divisible by p.
-- Then make the ring Rmodp whose coefficient ring is Z/p and return
-- the ideal Imodp of Rmodp generated by Gmodp whose elements are
-- mapped from G by mod p.
modpOf = (I, p) -> (
  if (not isPrime p) then ( error "[modpOf] not prime" );
  R := ring I;
  R2Z := map(ZZ, R);
  Rmodp := (ZZ/p)[gens R];
  R2Rmodp := map(Rmodp, R);
  -- Groebner basis of integral coefficients
  G := flatten entries gens gb I;
  -- compute lcm of initial coefficients of G
  lcmlc := 1;
  for g in G do (
    lc := R2Z (last coefficients first terms g)_0_0;
    lcmlc = lcm(lcmlc, lc);
  );
  << "prime factors of initial coefficients of G.B. are" << endl;
  << toList apply(factor lcmlc, t -> t#0) << endl;
  if (lcmlc % p == 0) then ( error "[modpOf] p is inappropriate." );
  -- make the Groebner basis 'G mod p' of the ideal 'I mod p'
  Gmodp := G / R2Rmodp;
  Imodp := ideal Gmodp
);

-- Do the same thing as 'modpOf', but returns Imodp2 instead of Imodp
-- in 'modpOf'.  Imodp2 is an ideal of Rmodp generated by images of
-- generators of I (not of G) by mod p.
-- If the Hilbert function of Rmodp / Imodp2 is not equal to
-- that of R/I then this function generates an error.
modpOf2 = (I, p) -> (
  if (not isPrime p) then ( error "[modpOf2] not prime" );
  R := ring I;
  R2Z := map(ZZ, R);
  Rmodp := (ZZ/p)[gens R];
  R2Rmodp := map(Rmodp, R);
  -- Groebner basis of integral coefficients
  G := flatten entries gens gb I;
  -- compute lcm of initial coefficients of G
  lcmlc := 1;
  for g in G do (
    lc := R2Z (last coefficients first terms g)_0_0;
    lcmlc = lcm(lcmlc, lc);
  );
  << "prime factors of initial coefficients of G.B. are" << endl;
  << toList apply(factor lcmlc, t -> t#0) << endl;
  if (lcmlc % p == 0) then ( error "[modpOf2] p is inappropriate." );
  -- make the ideal 'I mod p'
  Imodp2 := ideal((flatten entries gens I) / R2Rmodp);
  if (hilb I != hilb Imodp2) then ( 
    error "[modpOf2] Hilbert functions differ."
  );
  Imodp2
);
